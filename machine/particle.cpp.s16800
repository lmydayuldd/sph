#include "thing/particle.h"

#include <iostream>
#include <random>

#include "gl/matrices.h"
#include "physics/vector.h"
#include "shape/dot.h"
#include "shape/sphere.h"
#include "util/constants.h"

Particle::Particle()
{
}

Particle::Particle(Flow* parentFlow)
    : parentFlow(parentFlow)
{
    m = 1.0;
    r = Vector(
        (static_cast<float>(rand()) / static_cast<float>(RAND_MAX) - 1.0f) * (rand()%5),
        (static_cast<float>(rand()) / static_cast<float>(RAND_MAX) - 1.0f) * (rand()%5),
        0//(static_cast<float>(rand()) / static_cast<float>(RAND_MAX) - 1.0f) * (rand()%5)
    );
    v = Vector(
        (static_cast<float>(rand()) / static_cast<float>(RAND_MAX) - 1.0f) * (rand()%30),
        (static_cast<float>(rand()) / static_cast<float>(RAND_MAX) - 1.0f) * (rand()%30),
        0//(static_cast<float>(rand()) / static_cast<float>(RAND_MAX) - 1.0f) * (rand()%30)
    );
    dv = Vector();
    dr = Vector();
    F = Vector();

    if (shapes.size() == 0) {
        float color[3] = {1.0f, 0, 0};
        Sphere sphere(0.8, color);
        this->shapes.push_back(sphere.shape);
//        float position[3] = {0, 0, 0};
//        Dot dot(position, color);
//        this->shapes.push_back(dot.shape);
    }
}

void Particle::springify(Particle* p2, float ks, float d, float kd)
{
    springs.push_back(Spring(p2, ks, d, kd));
}
void Particle::springifyMutual(Particle* p2, float ks, float d, float kd)
{
    springs.push_back(Spring(p2, ks, d, kd));
    p2->springs.push_back(Spring(this, ks, d, kd)); ////////////////////////////////
}

void Particle::setModelMatrix()
{
    Matrices::modelMatrix.setToIdentity();
    Matrices::modelMatrix.translate(QVector3D(r.x, r.y, r.z));
    Matrices::modelMatrix.scale(QVector3D(radius, radius, radius));
    //Matrices::modelMatrix.rotate(100.0f * SimulationWindow::frame / SimulationWindow::refreshRate, 0, 1, 0);

    // x y z // r theta phi // radius inclination azimuth // yaw roll pitch
    Vector dir = v.normal();
    Vector up = Vector(0, 1, 0);
    double angle = - acos(dir.dotProduct(up)) * Constants::radToDeg;
    if (fabs(angle) > 0.5) {
        Vector axis = (dir * up).normal();
        Matrices::modelMatrix.rotate(angle, QVector3D(axis.x, axis.y, axis.z)); // rotate towards velocity direction vector
    }
}

void Particle::paint()
{
    setModelMatrix();

    Primitive::paint();

//    v.setApplicationPoint(r);
//    v.paint();
}
